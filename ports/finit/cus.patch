--- finit-3.0-rc2/watchdog.c	2016-10-23 22:02:19.000000000 +0000
+++ finit-3.0-rc2/watchdog.c	2016-10-23 22:02:19.000000000 +0000
@@ -25,6 +25,7 @@
 #include <sys/un.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
+#include <sys/signal.h>
 #include <linux/watchdog.h>
 
 #include "finit.h"

--- finit-3.0-rc2/sig.c	2016-11-27 16:26:38.000000000 +0000
+++ finit-3.0-rc2/sig.c	2016-11-27 16:26:38.000000000 +0000
@@ -194,23 +194,26 @@
 	/* Call mdadm to mark any RAID array(s) as clean before halting. */
 	mdadm_wait();
 
-	/* Wait here until the WDT reboots, or timeout */
-	if (wdogpid) {
-		int timeout = 10;
+	/* Reboot via watchdog or kernel, or shutdown? */
+	if (op == SHUT_REBOOT) {
+		if (wdogpid) {
+			int timeout = 10;
+
+			/* Wait here until the WDT reboots, or timeout with fallback */
+			print(kill(wdogpid, SIGPWR) == 1, "Pending watchdog reboot");
+			while (timeout--)
+				do_sleep(1);
+		}
 
-		print(kill(wdogpid, SIGPWR) == 1, "Pending watchdog reboot");
-		while (timeout--)
-			do_sleep(1);
-	}
-
-	_d("%s", op == SHUT_REBOOT ? "Rebooting" : "Halting");
-	if (op == SHUT_REBOOT)
+		_d("Rebooting ...");
 		reboot(RB_AUTOBOOT);
-
-	if (op == SHUT_OFF)
+	} else if (op == SHUT_OFF) {
+		_d("Powering down ...");
 		reboot(RB_POWER_OFF);
+	}
 
 	/* Also fallback if any of the other two fails */
+	_d("Halting ...");
 	reboot(RB_HALT_SYSTEM);
 }
 
diff --git a/finit.c b/finit.c
index edb9cf5..6a5f623 100644
--- a/finit.c
+++ b/finit.c
@@ -77,6 +77,28 @@ static int banner(void)
 	return 0;
 }
 
+/* Requires /proc to be mounted */
+static int fismnt(char *dir)
+{
+	FILE *fp;
+	int found = 0;
+	struct mntent *mnt;
+
+	fp = setmntent("/proc/mounts", "r");
+	if (!fp)
+		return 0;	/* Dunno, maybe not */
+
+	while ((mnt = getmntent(fp))) {
+		if (!strcmp(mnt->mnt_dir, dir)) {
+			found = 1;
+			break;
+		}
+	}
+	endmntent(fp);
+
+	return found;
+}
+
 /*
  * Check all filesystems in /etc/fstab with a fs_passno > 0
  */
@@ -108,6 +130,11 @@ static int fsck(int pass)
 			}
 		}
 
+		if (fismnt(fs->fs_file)) {
+			_d("Skipping fsck of %s, already mounted on %s.", fs->fs_spec, fs->fs_file);
+			continue;
+		}
+
 		snprintf(cmd, sizeof(cmd), "/sbin/fsck -a %s", fs->fs_spec);
 		run_interactive(cmd, "Checking filesystem %.13s", fs->fs_spec);
 	}
@@ -164,28 +191,6 @@ static void networking(void)
 	ifconfig("lo", "127.0.0.1", "255.0.0.0", 1);
 }
 
-/* Requires /proc to be mounted */
-static int fismnt(char *dir)
-{
-	FILE *fp;
-	int found = 0;
-	struct mntent *mnt;
-
-	fp = setmntent("/proc/mounts", "r");
-	if (!fp)
-		return 0;	/* Dunno, maybe not */
-
-	while ((mnt = getmntent(fp))) {
-		if (!strcmp(mnt->mnt_dir, dir)) {
-			found = 1;
-			break;
-		}
-	}
-	endmntent(fp);
-
-	return found;
-}
-
 /*
  * If everything goes south we can use this to give the operator an
  * emergency shell to debug the problem -- Finit should not crash!
@@ -247,14 +252,6 @@ int main(int argc, char* argv[])
 	ctx = &loop;
 
 	/*
-	 * Check file filesystems in /etc/fstab
-	 */
-	for (int pass = 1; pass < 10; pass++) {
-		if (fsck(pass))
-			break;
-	}
-
-	/*
 	 * Mount base file system, kernel is assumed to run devtmpfs for /dev
 	 */
 	chdir("/");
@@ -264,6 +261,14 @@ int main(int argc, char* argv[])
 	mount("none", "/sys", "sysfs", 0, NULL);
 
 	/*
+	 * Check file filesystems in /etc/fstab
+	 */
+	for (int pass = 1; pass < 10; pass++) {
+		if (fsck(pass))
+			break;
+	}
+
+	/*
 	 * Some non-embedded systems without an initramfs may not have /dev mounted yet
 	 * If they do, check if system has udevadm and perform cleanup from initramfs
 	 */
