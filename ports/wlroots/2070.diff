diff --git a/backend/drm/atomic.c b/backend/drm/atomic.c
index cf5367464..574f4518f 100644
--- a/backend/drm/atomic.c
+++ b/backend/drm/atomic.c
@@ -1,5 +1,6 @@
 #include <gbm.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <wlr/util/log.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
@@ -158,6 +159,10 @@ static void set_plane_props(struct atomic *atom, struct wlr_drm_backend *drm,
 	atomic_add(atom, id, props->crtc_x, (uint64_t)x);
 	atomic_add(atom, id, props->crtc_y, (uint64_t)y);
 
+	if (props->in_fence_fd) {
+		atomic_add(atom, id, props->in_fence_fd, plane->in_fence_fd);
+	}
+
 	return;
 
 error:
@@ -204,6 +209,15 @@ static bool atomic_crtc_commit(struct wlr_drm_backend *drm,
 		vrr_enabled = output->pending.adaptive_sync_enabled;
 	}
 
+	int *out_fence_ptr = NULL;
+	if (!(flags & DRM_MODE_ATOMIC_TEST_ONLY)) {
+		if (crtc->out_fence_fd >= 0) {
+			close(crtc->out_fence_fd);
+		}
+		crtc->out_fence_fd = -1;
+		out_fence_ptr = &crtc->out_fence_fd;
+	}
+
 	if (crtc->pending_modeset) {
 		flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
 	} else {
@@ -237,6 +251,10 @@ static bool atomic_crtc_commit(struct wlr_drm_backend *drm,
 				plane_disable(&atom, crtc->cursor);
 			}
 		}
+		if (crtc->props.out_fence_ptr && out_fence_ptr != NULL) {
+			atomic_add(&atom, crtc->id, crtc->props.out_fence_ptr,
+				(uintptr_t)out_fence_ptr);
+		}
 	} else {
 		plane_disable(&atom, crtc->primary);
 		if (crtc->cursor) {
diff --git a/backend/drm/drm.c b/backend/drm/drm.c
index 7153761ad..f3c6420a3 100644
--- a/backend/drm/drm.c
+++ b/backend/drm/drm.c
@@ -3,6 +3,7 @@
 #include <drm_fourcc.h>
 #include <drm_mode.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <gbm.h>
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
@@ -13,6 +14,7 @@
 #include <string.h>
 #include <strings.h>
 #include <time.h>
+#include <unistd.h>
 #include <wayland-server-core.h>
 #include <wayland-util.h>
 #include <wlr/backend/interface.h>
@@ -98,6 +100,7 @@ static bool add_plane(struct wlr_drm_backend *drm,
 	p->type = type;
 	p->id = drm_plane->plane_id;
 	p->props = *props;
+	p->in_fence_fd = -1;
 
 	for (size_t j = 0; j < drm_plane->count_formats; ++j) {
 		wlr_drm_format_set_add(&p->formats, drm_plane->formats[j],
@@ -166,6 +169,15 @@ static bool add_plane(struct wlr_drm_backend *drm,
 	return false;
 }
 
+static void destroy_plane(struct wlr_drm_plane *plane) {
+	if (plane == NULL) {
+		return;
+	}
+	close(plane->in_fence_fd);
+	wlr_drm_format_set_finish(&plane->formats);
+	free(plane);
+}
+
 static bool init_planes(struct wlr_drm_backend *drm) {
 	drmModePlaneRes *plane_res = drmModeGetPlaneResources(drm->fd);
 	if (!plane_res) {
@@ -270,6 +282,7 @@ bool init_drm_resources(struct wlr_drm_backend *drm) {
 		struct wlr_drm_crtc *crtc = &drm->crtcs[i];
 		crtc->id = res->crtcs[i];
 		crtc->legacy_crtc = drmModeGetCrtc(drm->fd, crtc->id);
+		crtc->out_fence_fd = -1;
 		get_drm_crtc_props(drm->fd, crtc->id, &crtc->props);
 	}
 
@@ -305,15 +318,11 @@ void finish_drm_resources(struct wlr_drm_backend *drm) {
 			drmModeDestroyPropertyBlob(drm->fd, crtc->gamma_lut);
 		}
 
-		if (crtc->primary) {
-			wlr_drm_format_set_finish(&crtc->primary->formats);
-			free(crtc->primary);
-		}
-		if (crtc->cursor) {
-			wlr_drm_format_set_finish(&crtc->cursor->formats);
-			free(crtc->cursor);
-		}
+		destroy_plane(crtc->primary);
+		destroy_plane(crtc->cursor);
+
 		free(crtc->overlays);
+		close(crtc->out_fence_fd);
 	}
 
 	free(drm->crtcs);
@@ -342,6 +351,11 @@ static bool drm_crtc_commit(struct wlr_drm_connector *conn, uint32_t flags) {
 		if (crtc->cursor != NULL) {
 			drm_fb_move(&crtc->cursor->queued_fb, &crtc->cursor->pending_fb);
 		}
+		if (crtc->out_fence_fd >= 0 &&
+				crtc->primary->queued_fb.type == WLR_DRM_FB_TYPE_WLR_BUFFER) {
+			wlr_buffer_add_out_fence(crtc->primary->queued_fb.wlr_buf,
+				crtc->out_fence_fd);
+		}
 	} else {
 		memcpy(&crtc->pending, &crtc->current, sizeof(struct wlr_drm_crtc_state));
 		drm_fb_clear(&crtc->primary->pending_fb);
@@ -481,9 +495,13 @@ static bool drm_connector_commit_buffer(struct wlr_output *output) {
 	}
 	struct wlr_drm_plane *plane = crtc->primary;
 
+	int in_fence_fd = -1;
 	assert(output->pending.committed & WLR_OUTPUT_STATE_BUFFER);
 	switch (output->pending.buffer_type) {
 	case WLR_OUTPUT_STATE_BUFFER_RENDER:
+		// TODO: multi-GPU
+		in_fence_fd = wlr_renderer_dup_out_fence(drm->renderer.wlr_rend);
+
 		if (!drm_fb_lock_surface(&plane->pending_fb, &plane->surf)) {
 			wlr_log(WLR_ERROR, "drm_fb_lock_surface failed");
 			return false;
@@ -498,9 +516,21 @@ static bool drm_connector_commit_buffer(struct wlr_output *output) {
 				&crtc->primary->formats)) {
 			return false;
 		}
+
+		if (buffer->in_fence_fd >= 0) {
+			in_fence_fd = fcntl(buffer->in_fence_fd, F_DUPFD_CLOEXEC);
+			if (in_fence_fd < 0) {
+				wlr_log_errno(WLR_ERROR, "dup failed");
+			}
+		}
 		break;
 	}
 
+	if (plane->in_fence_fd >= 0) {
+		close(plane->in_fence_fd);
+	}
+	plane->in_fence_fd = in_fence_fd;
+
 	if (!drm_crtc_page_flip(conn)) {
 		return false;
 	}
@@ -861,7 +891,8 @@ struct wlr_output_mode *wlr_drm_connector_add_mode(struct wlr_output *output,
 static bool drm_connector_set_cursor(struct wlr_output *output,
 		struct wlr_texture *texture, float scale,
 		enum wl_output_transform transform,
-		int32_t hotspot_x, int32_t hotspot_y, bool update_texture) {
+		int32_t hotspot_x, int32_t hotspot_y, bool update_texture,
+		struct wlr_buffer *buffer) {
 	struct wlr_drm_connector *conn = get_drm_connector_from_output(output);
 	struct wlr_drm_backend *drm = get_drm_backend_from_backend(output->backend);
 	struct wlr_drm_crtc *crtc = conn->crtc;
@@ -932,6 +963,10 @@ static bool drm_connector_set_cursor(struct wlr_output *output,
 
 		struct wlr_renderer *rend = plane->surf.renderer->wlr_rend;
 
+		if (buffer != NULL && buffer->in_fence_fd >= 0) {
+			wlr_renderer_wait_in_fence(rend, buffer->in_fence_fd);
+		}
+
 		struct wlr_box cursor_box = { .width = width, .height = height };
 
 		float matrix[9];
@@ -941,6 +976,7 @@ static bool drm_connector_set_cursor(struct wlr_output *output,
 		wlr_renderer_clear(rend, (float[]){ 0.0, 0.0, 0.0, 0.0 });
 		wlr_render_texture_with_matrix(rend, texture, matrix, 1.0);
 		wlr_renderer_end(rend);
+		// TODO: get out fence
 
 		if (!drm_fb_lock_surface(&plane->pending_fb, &plane->surf)) {
 			return false;
@@ -1009,6 +1045,14 @@ bool drm_connector_is_cursor_visible(struct wlr_drm_connector *conn) {
 		conn->cursor_y + (int)plane->surf.height >= 0;
 }
 
+static int drm_connector_get_out_fence(struct wlr_output *output) {
+	struct wlr_drm_connector *conn = get_drm_connector_from_output(output);
+	if (conn->crtc == NULL) {
+		return -1;
+	}
+	return conn->crtc->out_fence_fd;
+}
+
 static void drm_connector_destroy(struct wlr_output *output) {
 	struct wlr_drm_connector *conn = get_drm_connector_from_output(output);
 	drm_connector_cleanup(conn);
@@ -1027,6 +1071,7 @@ static const struct wlr_output_impl output_impl = {
 	.rollback_render = drm_connector_rollback_render,
 	.get_gamma_size = drm_connector_get_gamma_size,
 	.export_dmabuf = drm_connector_export_dmabuf,
+	.get_out_fence = drm_connector_get_out_fence,
 };
 
 bool wlr_output_is_drm(struct wlr_output *output) {
diff --git a/backend/drm/properties.c b/backend/drm/properties.c
index 0fafca7b7..a03a4a96e 100644
--- a/backend/drm/properties.c
+++ b/backend/drm/properties.c
@@ -34,6 +34,7 @@ static const struct prop_info crtc_info[] = {
 	{ "GAMMA_LUT", INDEX(gamma_lut) },
 	{ "GAMMA_LUT_SIZE", INDEX(gamma_lut_size) },
 	{ "MODE_ID", INDEX(mode_id) },
+	{ "OUT_FENCE_PTR", INDEX(out_fence_ptr) },
 	{ "VRR_ENABLED", INDEX(vrr_enabled) },
 	{ "rotation", INDEX(rotation) },
 	{ "scaling mode", INDEX(scaling_mode) },
@@ -48,6 +49,7 @@ static const struct prop_info plane_info[] = {
 	{ "CRTC_X", INDEX(crtc_x) },
 	{ "CRTC_Y", INDEX(crtc_y) },
 	{ "FB_ID", INDEX(fb_id) },
+	{ "IN_FENCE_FD", INDEX(in_fence_fd) },
 	{ "IN_FORMATS", INDEX(in_formats) },
 	{ "SRC_H", INDEX(src_h) },
 	{ "SRC_W", INDEX(src_w) },
diff --git a/backend/wayland/output.c b/backend/wayland/output.c
index bd17fa208..21721b087 100644
--- a/backend/wayland/output.c
+++ b/backend/wayland/output.c
@@ -310,7 +310,8 @@ static void output_rollback_render(struct wlr_output *wlr_output) {
 static bool output_set_cursor(struct wlr_output *wlr_output,
 		struct wlr_texture *texture, float scale,
 		enum wl_output_transform transform,
-		int32_t hotspot_x, int32_t hotspot_y, bool update_texture) {
+		int32_t hotspot_x, int32_t hotspot_y, bool update_texture,
+		struct wlr_buffer *buffer) {
 	struct wlr_wl_output *output = get_wl_output_from_output(wlr_output);
 	struct wlr_wl_backend *backend = output->backend;
 
diff --git a/include/backend/drm/drm.h b/include/backend/drm/drm.h
index c56850791..127fc3d61 100644
--- a/include/backend/drm/drm.h
+++ b/include/backend/drm/drm.h
@@ -39,6 +39,8 @@ struct wlr_drm_plane {
 	bool cursor_enabled;
 	int32_t cursor_hotspot_x, cursor_hotspot_y;
 
+	int in_fence_fd;
+
 	union wlr_drm_plane_props props;
 };
 
@@ -71,6 +73,8 @@ struct wlr_drm_crtc {
 	uint32_t *overlays;
 
 	union wlr_drm_crtc_props props;
+
+	int out_fence_fd;
 };
 
 struct wlr_drm_backend {
diff --git a/include/backend/drm/properties.h b/include/backend/drm/properties.h
index fba444aa2..cfc43b117 100644
--- a/include/backend/drm/properties.h
+++ b/include/backend/drm/properties.h
@@ -38,6 +38,7 @@ union wlr_drm_crtc_props {
 
 		uint32_t active;
 		uint32_t mode_id;
+		uint32_t out_fence_ptr;
 	};
 	uint32_t props[6];
 };
@@ -60,6 +61,7 @@ union wlr_drm_plane_props {
 		uint32_t crtc_h;
 		uint32_t fb_id;
 		uint32_t crtc_id;
+		uint32_t in_fence_fd;
 	};
 	uint32_t props[13];
 };
diff --git a/include/render/gles2.h b/include/render/gles2.h
index 24c02e4dc..be893bf6f 100644
--- a/include/render/gles2.h
+++ b/include/render/gles2.h
@@ -70,6 +70,7 @@ struct wlr_gles2_renderer {
 	} shaders;
 
 	uint32_t viewport_width, viewport_height;
+	EGLSyncKHR end_sync;
 };
 
 struct wlr_gles2_texture {
diff --git a/include/render/sync_file.h b/include/render/sync_file.h
new file mode 100644
index 000000000..613726d05
--- /dev/null
+++ b/include/render/sync_file.h
@@ -0,0 +1,9 @@
+#ifndef RENDER_SYNC_FILE_H
+#define RENDER_SYNC_FILE_H
+
+#include <stdbool.h>
+
+bool fd_is_sync_file(int fd);
+int sync_file_merge(int fd1, int fd2);
+
+#endif
diff --git a/include/wlr/render/egl.h b/include/wlr/render/egl.h
index d46d95aff..7d7f25c18 100644
--- a/include/wlr/render/egl.h
+++ b/include/wlr/render/egl.h
@@ -67,6 +67,10 @@ struct wlr_egl {
 		PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC eglExportDMABUFImageQueryMESA;
 		PFNEGLEXPORTDMABUFIMAGEMESAPROC eglExportDMABUFImageMESA;
 		PFNEGLDEBUGMESSAGECONTROLKHRPROC eglDebugMessageControlKHR;
+		PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR;
+		PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR;
+		PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+		PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR;
 	} procs;
 
 	struct wl_display *wl_display;
@@ -161,4 +165,12 @@ bool wlr_egl_swap_buffers(struct wlr_egl *egl, EGLSurface surface,
 
 bool wlr_egl_destroy_surface(struct wlr_egl *egl, EGLSurface surface);
 
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd);
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync);
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
 #endif
diff --git a/include/wlr/render/interface.h b/include/wlr/render/interface.h
index 93c987b7d..8dfc4f6ca 100644
--- a/include/wlr/render/interface.h
+++ b/include/wlr/render/interface.h
@@ -54,6 +54,8 @@ struct wlr_renderer_impl {
 		uint32_t *flags, uint32_t stride, uint32_t width, uint32_t height,
 		uint32_t src_x, uint32_t src_y, uint32_t dst_x, uint32_t dst_y,
 		void *data);
+	int (*dup_out_fence)(struct wlr_renderer *renderer);
+	bool (*wait_in_fence)(struct wlr_renderer *renderer, int fd);
 	struct wlr_texture *(*texture_from_pixels)(struct wlr_renderer *renderer,
 		enum wl_shm_format fmt, uint32_t stride, uint32_t width,
 		uint32_t height, const void *data);
diff --git a/include/wlr/render/wlr_renderer.h b/include/wlr/render/wlr_renderer.h
index 513f412a1..f54874a92 100644
--- a/include/wlr/render/wlr_renderer.h
+++ b/include/wlr/render/wlr_renderer.h
@@ -135,4 +135,15 @@ bool wlr_renderer_init_wl_display(struct wlr_renderer *r,
  */
 void wlr_renderer_destroy(struct wlr_renderer *renderer);
 
+/**
+ * Create a new fence that will be signalled when rendering completes.
+ *
+ * This function must be called after wlr_renderer_end.
+ */
+int wlr_renderer_dup_out_fence(struct wlr_renderer *renderer);
+/**
+ * Wait for a fence before executing the next rendering operations.
+ */
+bool wlr_renderer_wait_in_fence(struct wlr_renderer *renderer, int fd);
+
 #endif
diff --git a/include/wlr/types/wlr_buffer.h b/include/wlr/types/wlr_buffer.h
index 14bb2a8da..0ec6a293d 100644
--- a/include/wlr/types/wlr_buffer.h
+++ b/include/wlr/types/wlr_buffer.h
@@ -37,6 +37,8 @@ struct wlr_buffer {
 	bool dropped;
 	size_t n_locks;
 
+	int in_fence_fd, out_fence_fd;
+
 	struct {
 		struct wl_signal destroy;
 		struct wl_signal release;
@@ -77,6 +79,17 @@ void wlr_buffer_unlock(struct wlr_buffer *buffer);
 bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer,
 	struct wlr_dmabuf_attributes *attribs);
 
+/**
+ * Should be called after writing to the buffer with a fence which will be
+ * signalled once writing is complete.
+ */
+void wlr_buffer_set_in_fence(struct wlr_buffer *buffer, int fd);
+/**
+ * Should be called after reading from the buffer with a fence which will be
+ * signalled once reading is complete.
+ */
+void wlr_buffer_add_out_fence(struct wlr_buffer *buffer, int fd);
+
 /**
  * A client buffer.
  */
diff --git a/include/wlr/types/wlr_linux_explicit_synchronization_v1.h b/include/wlr/types/wlr_linux_explicit_synchronization_v1.h
new file mode 100644
index 000000000..05a7d904a
--- /dev/null
+++ b/include/wlr/types/wlr_linux_explicit_synchronization_v1.h
@@ -0,0 +1,54 @@
+/*
+ * This an unstable interface of wlroots. No guarantees are made regarding the
+ * future consistency of this API.
+ */
+#ifndef WLR_USE_UNSTABLE
+#error "Add -DWLR_USE_UNSTABLE to enable unstable wlroots features"
+#endif
+
+#ifndef WLR_TYPES_WLR_LINUX_EXPLICIT_SYNCHRONIZATION_H
+#define WLR_TYPES_WLR_LINUX_EXPLICIT_SYNCHRONIZATION_H
+
+#include <wayland-server-core.h>
+
+struct wlr_linux_surface_synchronization_v1 {
+	struct wl_resource *resource;
+	struct wlr_surface *surface;
+
+	int pending_fence_fd;
+	struct wlr_linux_buffer_release_v1 *pending_buffer_release;
+
+	struct wl_listener surface_destroy;
+	struct wl_listener surface_commit;
+};
+
+struct wlr_linux_buffer_release_v1 {
+	struct wl_resource *resource;
+
+	struct wlr_buffer *buffer;
+
+	struct wl_listener buffer_destroy;
+	struct wl_listener buffer_release;
+};
+
+struct wlr_linux_explicit_synchronization_v1 {
+	struct wl_global *global;
+
+	struct {
+		struct wl_signal destroy;
+	} events;
+
+	struct wl_listener display_destroy;
+};
+
+/**
+ * Advertise explicit synchronization support to clients.
+ *
+ * The compositor must be prepared to handle fences coming from clients and to
+ * send release fences correctly. In particular, both the renderer and the
+ * backend need to support explicit synchronization.
+ */
+struct wlr_linux_explicit_synchronization_v1 *
+wlr_linux_explicit_synchronization_v1_create(struct wl_display *display);
+
+#endif
diff --git a/include/wlr/types/wlr_output.h b/include/wlr/types/wlr_output.h
index 075d09a1f..4ee123d89 100644
--- a/include/wlr/types/wlr_output.h
+++ b/include/wlr/types/wlr_output.h
@@ -420,6 +420,13 @@ void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock);
  */
 void wlr_output_render_software_cursors(struct wlr_output *output,
 	pixman_region32_t *damage);
+/**
+ * Get the fence FD that will be signalled when buffers submitted with the last
+ * output commit stop being used.
+ *
+ * The returned FD must not be closed by the caller.
+ */
+int wlr_output_get_out_fence(struct wlr_output *output);
 
 
 struct wlr_output_cursor *wlr_output_cursor_create(struct wlr_output *output);
diff --git a/meson.build b/meson.build
index a6dad5d6c..3792587c2 100644
--- a/meson.build
+++ b/meson.build
@@ -87,6 +87,7 @@ conf_data.set10('WLR_HAS_XWAYLAND', false)
 conf_data.set10('WLR_HAS_XCB_ERRORS', false)
 conf_data.set10('WLR_HAS_XCB_ICCCM', false)
 conf_data.set10('WLR_HAS_EGLMESAEXT_H', false)
+conf_data.set10('WLR_HAS_LINUX_SYNC_FILE', false)
 
 # Clang complains about some zeroed initializer lists (= {0}), even though they
 # are valid
diff --git a/protocol/meson.build b/protocol/meson.build
index 2369b70e3..573be3b14 100644
--- a/protocol/meson.build
+++ b/protocol/meson.build
@@ -20,6 +20,7 @@ protocols = {
 	'idle-inhibit-unstable-v1': wl_protocol_dir / 'unstable/idle-inhibit/idle-inhibit-unstable-v1.xml',
 	'keyboard-shortcuts-inhibit-unstable-v1': wl_protocol_dir / 'unstable/keyboard-shortcuts-inhibit/keyboard-shortcuts-inhibit-unstable-v1.xml',
 	'linux-dmabuf-unstable-v1': wl_protocol_dir / 'unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml',
+	'linux-explicit-synchronization-unstable-v1': wl_protocol_dir / 'unstable/linux-explicit-synchronization/linux-explicit-synchronization-unstable-v1.xml',
 	'pointer-constraints-unstable-v1': wl_protocol_dir / 'unstable/pointer-constraints/pointer-constraints-unstable-v1.xml',
 	'pointer-gestures-unstable-v1': wl_protocol_dir / 'unstable/pointer-gestures/pointer-gestures-unstable-v1.xml',
 	'primary-selection-unstable-v1': wl_protocol_dir / 'unstable/primary-selection/primary-selection-unstable-v1.xml',
diff --git a/render/egl.c b/render/egl.c
index 797d8f15a..829f2732d 100644
--- a/render/egl.c
+++ b/render/egl.c
@@ -1,7 +1,10 @@
+#define _POSIX_C_SOURCE 200809L
 #include <assert.h>
 #include <drm_fourcc.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <wlr/render/egl.h>
 #include <wlr/util/log.h>
 #include <wlr/util/region.h>
@@ -289,6 +292,18 @@ bool wlr_egl_init(struct wlr_egl *egl, EGLenum platform, void *remote_display,
 			"eglQueryWaylandBufferWL");
 	}
 
+	if (check_egl_ext(display_exts_str, "EGL_KHR_fence_sync") &&
+			check_egl_ext(display_exts_str, "EGL_ANDROID_native_fence_sync")) {
+		load_egl_proc(&egl->procs.eglCreateSyncKHR, "eglCreateSyncKHR");
+		load_egl_proc(&egl->procs.eglDestroySyncKHR, "eglDestroySyncKHR");
+		load_egl_proc(&egl->procs.eglDupNativeFenceFDANDROID,
+			"eglDupNativeFenceFDANDROID");
+	}
+
+	if (check_egl_ext(display_exts_str, "EGL_KHR_wait_sync")) {
+		load_egl_proc(&egl->procs.eglWaitSyncKHR, "eglWaitSyncKHR");
+	}
+
 	if (!egl_get_config(egl->display, config_attribs, &egl->config, visual_id)) {
 		wlr_log(WLR_ERROR, "Failed to get EGL config");
 		goto error;
@@ -805,3 +820,65 @@ bool wlr_egl_destroy_surface(struct wlr_egl *egl, EGLSurface surface) {
 	}
 	return eglDestroySurface(egl->display, surface);
 }
+
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd) {
+	if (!egl->procs.eglCreateSyncKHR) {
+		return EGL_NO_SYNC_KHR;
+	}
+
+	EGLint attribs[3] = { EGL_NONE };
+	int dup_fd = -1;
+	if (fence_fd >= 0) {
+		dup_fd = fcntl(fence_fd, F_DUPFD_CLOEXEC);
+		if (dup_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+			return EGL_NO_SYNC_KHR;
+		}
+
+		attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+		attribs[1] = dup_fd;
+		attribs[2] = EGL_NONE;
+	}
+
+	EGLSyncKHR sync = egl->procs.eglCreateSyncKHR(egl->display,
+		EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+	if (sync == EGL_NO_SYNC_KHR) {
+		wlr_log(WLR_ERROR, "eglCreateSyncKHR failed");
+		if (dup_fd >= 0) {
+			close(dup_fd);
+		}
+	}
+	return sync;
+}
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (sync == EGL_NO_SYNC_KHR) {
+		return;
+	}
+	assert(egl->procs.eglDestroySyncKHR);
+	if (egl->procs.eglDestroySyncKHR(egl->display, sync) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglDestroySyncKHR failed");
+	}
+}
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (!egl->procs.eglDupNativeFenceFDANDROID) {
+		return -1;
+	}
+
+	int fd = egl->procs.eglDupNativeFenceFDANDROID(egl->display, sync);
+	if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+		wlr_log(WLR_ERROR, "eglDupNativeFenceFDANDROID failed");
+		return -1;
+	}
+
+	return fd;
+}
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (egl->procs.eglWaitSyncKHR(egl->display, sync, 0) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglWaitSyncKHR failed");
+		return false;
+	}
+	return true;
+}
diff --git a/render/meson.build b/render/meson.build
index 9486c22de..73fde4a94 100644
--- a/render/meson.build
+++ b/render/meson.build
@@ -6,6 +6,9 @@ wlr_files += files(
 	'gles2/renderer.c',
 	'gles2/shaders.c',
 	'gles2/texture.c',
+	'sync_file.c',
 	'wlr_renderer.c',
 	'wlr_texture.c',
 )
+
+conf_data.set10('WLR_HAS_LINUX_SYNC_FILE', cc.has_header('linux/sync_file.h'))
diff --git a/render/sync_file.c b/render/sync_file.c
new file mode 100644
index 000000000..2fa05bb21
--- /dev/null
+++ b/render/sync_file.c
@@ -0,0 +1,39 @@
+#include <wlr/util/log.h>
+#include "render/sync_file.h"
+
+#ifdef WLR_HAS_LINUX_SYNC_FILE
+
+#include <linux/sync_file.h>
+#include <sys/ioctl.h>
+
+bool fd_is_sync_file(int fd) {
+	struct sync_file_info info = {0};
+	if (ioctl(fd, SYNC_IOC_FILE_INFO, &info) < 0) {
+		return false;
+	}
+	return info.num_fences > 0;
+}
+
+int sync_file_merge(int fd1, int fd2) {
+	// The kernel will automatically prune signalled fences
+	struct sync_merge_data merge_data = { .fd2 = fd2 };
+	if (ioctl(fd1, SYNC_IOC_MERGE, &merge_data) < 0) {
+		wlr_log_errno(WLR_ERROR, "ioctl(SYNC_IOC_MERGE) failed");
+		return -1;
+	}
+
+	return merge_data.fence;
+}
+
+#else
+
+bool fd_is_sync_file(int fd) {
+	return false;
+}
+
+int sync_file_merge(int fd1, int fd2) {
+	wlr_log(WLR_ERROR, "sync_file support is unavailable");
+	return -1;
+}
+
+#endif
diff --git a/render/wlr_renderer.c b/render/wlr_renderer.c
index 593d165f4..31ec4121a 100644
--- a/render/wlr_renderer.c
+++ b/render/wlr_renderer.c
@@ -179,6 +179,22 @@ bool wlr_renderer_blit_dmabuf(struct wlr_renderer *r,
 	return r->impl->blit_dmabuf(r, dst, src);
 }
 
+int wlr_renderer_dup_out_fence(struct wlr_renderer *r) {
+	assert(!r->rendering);
+	if (!r->impl->dup_out_fence) {
+		return -1;
+	}
+	return r->impl->dup_out_fence(r);
+}
+
+bool wlr_renderer_wait_in_fence(struct wlr_renderer *r, int fd) {
+	assert(r->rendering);
+	if (!r->impl->wait_in_fence) {
+		return false;
+	}
+	return r->impl->wait_in_fence(r, fd);
+}
+
 bool wlr_renderer_format_supported(struct wlr_renderer *r,
 		enum wl_shm_format fmt) {
 	return r->impl->format_supported(r, fmt);
diff --git a/types/meson.build b/types/meson.build
index 998e6b455..0ca68fd41 100644
--- a/types/meson.build
+++ b/types/meson.build
@@ -41,6 +41,7 @@ wlr_files += files(
 	'wlr_keyboard_shortcuts_inhibit_v1.c',
 	'wlr_layer_shell_v1.c',
 	'wlr_linux_dmabuf_v1.c',
+	'wlr_linux_explicit_synchronization_v1.c',
 	'wlr_list.c',
 	'wlr_matrix.c',
 	'wlr_output_damage.c',
diff --git a/types/wlr_buffer.c b/types/wlr_buffer.c
index 2f914c127..88d486752 100644
--- a/types/wlr_buffer.c
+++ b/types/wlr_buffer.c
@@ -1,10 +1,14 @@
+#define _POSIX_C_SOURCE 200809L
 #include <assert.h>
+#include <fcntl.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_buffer.h>
 #include <wlr/types/wlr_linux_dmabuf_v1.h>
 #include <wlr/util/log.h>
 #include "util/signal.h"
+#include "render/sync_file.h"
 
 void wlr_buffer_init(struct wlr_buffer *buffer,
 		const struct wlr_buffer_impl *impl, int width, int height) {
@@ -12,6 +16,7 @@ void wlr_buffer_init(struct wlr_buffer *buffer,
 	buffer->impl = impl;
 	buffer->width = width;
 	buffer->height = height;
+	buffer->in_fence_fd = buffer->out_fence_fd = -1;
 	wl_signal_init(&buffer->events.destroy);
 	wl_signal_init(&buffer->events.release);
 }
@@ -23,6 +28,11 @@ static void buffer_consider_destroy(struct wlr_buffer *buffer) {
 
 	wlr_signal_emit_safe(&buffer->events.destroy, NULL);
 
+	assert(buffer->in_fence_fd < 0);
+	if (buffer->out_fence_fd >= 0) {
+		close(buffer->out_fence_fd);
+	}
+
 	buffer->impl->destroy(buffer);
 }
 
@@ -50,6 +60,11 @@ void wlr_buffer_unlock(struct wlr_buffer *buffer) {
 	buffer->n_locks--;
 
 	if (buffer->n_locks == 0) {
+		if (buffer->in_fence_fd >= 0) {
+			close(buffer->in_fence_fd);
+			buffer->in_fence_fd = -1;
+		}
+
 		wl_signal_emit(&buffer->events.release, NULL);
 	}
 
@@ -64,6 +79,30 @@ bool wlr_buffer_get_dmabuf(struct wlr_buffer *buffer,
 	return buffer->impl->get_dmabuf(buffer, attribs);
 }
 
+void wlr_buffer_set_in_fence(struct wlr_buffer *buffer, int fd) {
+	assert(buffer->in_fence_fd < 0); // can only be set once
+	buffer->in_fence_fd = fd;
+}
+
+void wlr_buffer_add_out_fence(struct wlr_buffer *buffer, int fd) {
+	if (buffer->out_fence_fd < 0) {
+		buffer->out_fence_fd = fcntl(fd, F_DUPFD_CLOEXEC);
+		if (buffer->out_fence_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+		}
+		return;
+	}
+
+	int merged = sync_file_merge(buffer->out_fence_fd, fd);
+	if (merged < 0) {
+		wlr_log(WLR_ERROR, "Failed to merge out fences");
+		return;
+	}
+
+	close(buffer->out_fence_fd);
+	buffer->out_fence_fd = merged;
+}
+
 
 bool wlr_resource_is_buffer(struct wl_resource *resource) {
 	return strcmp(wl_resource_get_class(resource), wl_buffer_interface.name) == 0;
diff --git a/types/wlr_linux_explicit_synchronization_v1.c b/types/wlr_linux_explicit_synchronization_v1.c
new file mode 100644
index 000000000..b334675e7
--- /dev/null
+++ b/types/wlr_linux_explicit_synchronization_v1.c
@@ -0,0 +1,309 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <wlr/types/wlr_linux_explicit_synchronization_v1.h>
+#include <wlr/types/wlr_surface.h>
+#include "linux-explicit-synchronization-unstable-v1-protocol.h"
+#include "render/sync_file.h"
+#include "util/signal.h"
+
+#define LINUX_EXPLICIT_SYNCHRONIZATION_V1_VERSION 2
+
+static const struct zwp_linux_surface_synchronization_v1_interface
+	surface_sync_impl;
+
+// Returns NULL if the surface sync is inert
+static struct wlr_linux_surface_synchronization_v1 *
+surface_sync_from_resource(struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&zwp_linux_surface_synchronization_v1_interface,
+		&surface_sync_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static struct wlr_linux_buffer_release_v1 *buffer_release_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&zwp_linux_buffer_release_v1_interface, NULL));
+	return wl_resource_get_user_data(resource);
+}
+
+static void buffer_release_handle_buffer_destroy(struct wl_listener *listener,
+		void *data) {
+	// This should never happen, a release event should always precede the
+	// destroy event
+	abort();
+}
+
+static void buffer_release_handle_buffer_release(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		wl_container_of(listener, buffer_release, buffer_release);
+	if (buffer_release->buffer->out_fence_fd >= 0) {
+		zwp_linux_buffer_release_v1_send_fenced_release(
+			buffer_release->resource, buffer_release->buffer->out_fence_fd);
+	} else {
+		zwp_linux_buffer_release_v1_send_immediate_release(
+			buffer_release->resource);
+	}
+	wl_resource_destroy(buffer_release->resource);
+}
+
+static void buffer_release_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		buffer_release_from_resource(resource);
+	wl_list_remove(&buffer_release->buffer_destroy.link);
+	wl_list_remove(&buffer_release->buffer_release.link);
+	free(buffer_release);
+}
+
+static void surface_sync_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static void surface_sync_handle_set_acquire_fence(struct wl_client *client,
+		struct wl_resource *resource, int fence_fd) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	if (surface_sync == NULL) {
+		close(fence_fd);
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_SURFACE,
+			"the surface has been destroyed");
+		return;
+	}
+
+	if (surface_sync->pending_fence_fd >= 0) {
+		close(fence_fd);
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_DUPLICATE_FENCE,
+			"a fence FD was already set for this commit");
+		return;
+	}
+
+	if (!fd_is_sync_file(fence_fd)) {
+		close(fence_fd);
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_INVALID_FENCE,
+			"the provided FD is not a Linux sync file");
+		return;
+	}
+
+	surface_sync->pending_fence_fd = fence_fd;
+}
+
+static void surface_sync_handle_get_release(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	if (surface_sync == NULL) {
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_SURFACE,
+			"the surface has been destroyed");
+		return;
+	}
+
+	if (surface_sync->pending_buffer_release != NULL) {
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_DUPLICATE_RELEASE,
+			"a buffer release has already been requested for this commit");
+		return;
+	}
+
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		calloc(1, sizeof(*buffer_release));
+	if (buffer_release == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	buffer_release->resource = wl_resource_create(client,
+		&zwp_linux_buffer_release_v1_interface, version, id);
+	if (buffer_release->resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		free(buffer_release);
+		return;
+	}
+	wl_resource_set_implementation(buffer_release->resource, NULL,
+		buffer_release, buffer_release_handle_resource_destroy);
+
+	wl_list_init(&buffer_release->buffer_destroy.link);
+	wl_list_init(&buffer_release->buffer_release.link);
+
+	surface_sync->pending_buffer_release = buffer_release;
+}
+
+static const struct zwp_linux_surface_synchronization_v1_interface
+		surface_sync_impl = {
+	.destroy = surface_sync_handle_destroy,
+	.set_acquire_fence = surface_sync_handle_set_acquire_fence,
+	.get_release = surface_sync_handle_get_release,
+};
+
+static void surface_sync_destroy(
+		struct wlr_linux_surface_synchronization_v1 *surface_sync) {
+	if (surface_sync == NULL) {
+		return;
+	}
+	wl_list_remove(&surface_sync->surface_destroy.link);
+	wl_list_remove(&surface_sync->surface_commit.link);
+	wl_resource_set_user_data(surface_sync->resource, NULL);
+	if (surface_sync->pending_fence_fd >= 0) {
+		close(surface_sync->pending_fence_fd);
+	}
+	if (surface_sync->pending_buffer_release != NULL) {
+		wl_resource_destroy(surface_sync->pending_buffer_release->resource);
+	}
+	free(surface_sync);
+}
+
+static void surface_sync_handle_surface_destroy(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		wl_container_of(listener, surface_sync, surface_destroy);
+	surface_sync_destroy(surface_sync);
+}
+
+static void surface_sync_handle_surface_commit(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		wl_container_of(listener, surface_sync, surface_commit);
+
+	if (surface_sync->pending_fence_fd >= 0) {
+		if (surface_sync->surface->buffer == NULL) {
+			wl_resource_post_error(surface_sync->resource,
+				ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_BUFFER,
+				"acquire fence FD set but no buffer attached");
+			return;
+		}
+
+		wlr_buffer_set_in_fence(&surface_sync->surface->buffer->base,
+			surface_sync->pending_fence_fd);
+	}
+
+	if (surface_sync->pending_buffer_release != NULL) {
+		if (surface_sync->surface->buffer == NULL) {
+			wl_resource_post_error(surface_sync->resource,
+				ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_BUFFER,
+				"buffer release requested but no buffer attached");
+			return;
+		}
+
+		struct wlr_buffer *buffer = &surface_sync->surface->buffer->base;
+		struct wlr_linux_buffer_release_v1 *buffer_release =
+			surface_sync->pending_buffer_release;
+
+		buffer_release->buffer = buffer;
+
+		buffer_release->buffer_destroy.notify =
+			buffer_release_handle_buffer_destroy;
+		wl_signal_add(&buffer->events.destroy, &buffer_release->buffer_destroy);
+
+		buffer_release->buffer_release.notify =
+			buffer_release_handle_buffer_release;
+		wl_signal_add(&buffer->events.release, &buffer_release->buffer_release);
+	}
+
+	surface_sync->pending_fence_fd = -1;
+	surface_sync->pending_buffer_release = NULL;
+}
+
+static void surface_sync_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	surface_sync_destroy(surface_sync);
+}
+
+static void explicit_sync_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static void explicit_sync_handle_get_synchronization(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id,
+		struct wl_resource *surface_resource) {
+	struct wlr_surface *surface = wlr_surface_from_resource(surface_resource);
+
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		calloc(1, sizeof(*surface_sync));
+	if (surface_sync == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	surface_sync->resource = wl_resource_create(client,
+		&zwp_linux_surface_synchronization_v1_interface, version, id);
+	if (surface_sync->resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		free(surface_sync);
+		return;
+	}
+	wl_resource_set_implementation(surface_sync->resource,
+		&surface_sync_impl, surface_sync, surface_sync_handle_resource_destroy);
+
+	surface_sync->surface = surface;
+	surface_sync->pending_fence_fd = -1;
+
+	surface_sync->surface_destroy.notify = surface_sync_handle_surface_destroy;
+	wl_signal_add(&surface->events.destroy, &surface_sync->surface_destroy);
+
+	surface_sync->surface_commit.notify = surface_sync_handle_surface_commit;
+	wl_signal_add(&surface->events.commit, &surface_sync->surface_commit);
+}
+
+static const struct zwp_linux_explicit_synchronization_v1_interface
+		explicit_sync_impl = {
+	.destroy = explicit_sync_handle_destroy,
+	.get_synchronization = explicit_sync_handle_get_synchronization,
+};
+
+static void explicit_sync_bind(struct wl_client *client, void *data,
+		uint32_t version, uint32_t id) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync = data;
+
+	struct wl_resource *resource = wl_resource_create(client,
+		&zwp_linux_explicit_synchronization_v1_interface, version, id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_resource_set_implementation(resource, &explicit_sync_impl,
+		explicit_sync, NULL);
+}
+
+static void handle_display_destroy(struct wl_listener *listener, void *data) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync =
+		wl_container_of(listener, explicit_sync, display_destroy);
+	wlr_signal_emit_safe(&explicit_sync->events.destroy, NULL);
+	wl_list_remove(&explicit_sync->display_destroy.link);
+	wl_global_destroy(explicit_sync->global);
+	free(explicit_sync);
+}
+
+struct wlr_linux_explicit_synchronization_v1 *
+wlr_linux_explicit_synchronization_v1_create(struct wl_display *display) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync =
+		calloc(1, sizeof(*explicit_sync));
+	if (explicit_sync == NULL) {
+		return NULL;
+	}
+
+	wl_signal_init(&explicit_sync->events.destroy);
+
+	explicit_sync->global = wl_global_create(display,
+		&zwp_linux_explicit_synchronization_v1_interface,
+		LINUX_EXPLICIT_SYNCHRONIZATION_V1_VERSION, explicit_sync,
+		explicit_sync_bind);
+	if (explicit_sync->global == NULL) {
+		free(explicit_sync);
+		return NULL;
+	}
+
+	explicit_sync->display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(display, &explicit_sync->display_destroy);
+
+	return explicit_sync;
+}
diff --git a/types/wlr_output.c b/types/wlr_output.c
index ce05f97b9..2abf902da 100644
--- a/types/wlr_output.c
+++ b/types/wlr_output.c
@@ -801,7 +801,7 @@ void wlr_output_lock_software_cursors(struct wlr_output *output, bool lock) {
 	if (output->software_cursor_locks > 0 && output->hardware_cursor != NULL) {
 		assert(output->impl->set_cursor);
 		output->impl->set_cursor(output, NULL, 1,
-			WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true);
+			WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true, NULL);
 		output_cursor_damage_whole(output->hardware_cursor);
 		output->hardware_cursor = NULL;
 	}
@@ -905,6 +905,13 @@ void wlr_output_render_software_cursors(struct wlr_output *output,
 	pixman_region32_fini(&render_damage);
 }
 
+int wlr_output_get_out_fence(struct wlr_output *output) {
+	if (!output->impl->get_out_fence) {
+		return -1;
+	}
+	return output->impl->get_out_fence(output);
+}
+
 
 /**
  * Returns the cursor box, scaled for its output.
@@ -976,10 +983,14 @@ static bool output_cursor_attempt_hardware(struct wlr_output_cursor *cursor) {
 	float scale = cursor->output->scale;
 	enum wl_output_transform transform = WL_OUTPUT_TRANSFORM_NORMAL;
 	struct wlr_texture *texture = cursor->texture;
+	struct wlr_buffer *buffer = NULL;
 	if (cursor->surface != NULL) {
 		texture = wlr_surface_get_texture(cursor->surface);
 		scale = cursor->surface->current.scale;
 		transform = cursor->surface->current.transform;
+		if (cursor->surface->buffer != NULL) {
+			buffer = &cursor->surface->buffer->base;
+		}
 	}
 
 	if (cursor->output->software_cursor_locks > 0) {
@@ -994,7 +1005,8 @@ static bool output_cursor_attempt_hardware(struct wlr_output_cursor *cursor) {
 		cursor->output->impl->move_cursor(cursor->output,
 			(int)cursor->x, (int)cursor->y);
 		if (cursor->output->impl->set_cursor(cursor->output, texture,
-				scale, transform, cursor->hotspot_x, cursor->hotspot_y, true)) {
+				scale, transform, cursor->hotspot_x, cursor->hotspot_y, true,
+				buffer)) {
 			cursor->output->hardware_cursor = cursor;
 			return true;
 		}
@@ -1103,7 +1115,8 @@ void wlr_output_cursor_set_surface(struct wlr_output_cursor *cursor,
 		} else {
 			assert(cursor->output->impl->set_cursor);
 			cursor->output->impl->set_cursor(cursor->output, NULL,
-				1, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y, false);
+				1, WL_OUTPUT_TRANSFORM_NORMAL, hotspot_x, hotspot_y, false,
+				NULL);
 		}
 		return;
 	}
@@ -1128,7 +1141,7 @@ void wlr_output_cursor_set_surface(struct wlr_output_cursor *cursor,
 		if (cursor->output->hardware_cursor == cursor) {
 			assert(cursor->output->impl->set_cursor);
 			cursor->output->impl->set_cursor(cursor->output, NULL, 1,
-				WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true);
+				WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true, NULL);
 		}
 	}
 }
@@ -1191,7 +1204,7 @@ void wlr_output_cursor_destroy(struct wlr_output_cursor *cursor) {
 		// If this cursor was the hardware cursor, disable it
 		if (cursor->output->impl->set_cursor) {
 			cursor->output->impl->set_cursor(cursor->output, NULL, 1,
-				WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true);
+				WL_OUTPUT_TRANSFORM_NORMAL, 0, 0, true, NULL);
 		}
 		cursor->output->hardware_cursor = NULL;
 	}
diff --git a/render/gles2/renderer.c b/render/gles2/renderer.c
index b20c3ac26..499dee515 100644
--- a/render/gles2/renderer.c
+++ b/render/gles2/renderer.c
@@ -23,6 +23,27 @@
 
 static const struct wlr_renderer_impl renderer_impl;
 
+static int gles2_dup_out_fence(struct wlr_renderer *wlr_renderer) {
+	struct wlr_gles2_renderer *renderer = gles2_get_renderer(wlr_renderer);
+	if (renderer->end_sync == EGL_NO_SYNC_KHR) {
+		return -1;
+	}
+	return wlr_egl_dup_fence_fd(renderer->egl, renderer->end_sync);
+}
+
+static bool gles2_wait_in_fence(struct wlr_renderer *wlr_renderer, int fd) {
+	struct wlr_gles2_renderer *renderer = gles2_get_renderer(wlr_renderer);
+
+	EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, fd);
+	if (sync == EGL_NO_SYNC_KHR) {
+		return false;
+	}
+
+	bool ok = wlr_egl_wait_sync(renderer->egl, sync);
+	wlr_egl_destroy_sync(renderer->egl, sync);
+	return ok;
+}
+
 struct wlr_gles2_renderer *gles2_get_renderer(
 		struct wlr_renderer *wlr_renderer) {
 	assert(wlr_renderer->impl == &renderer_impl);
@@ -41,6 +62,9 @@
 	struct wlr_gles2_renderer *renderer =
 		gles2_get_renderer_in_context(wlr_renderer);
 
+	wlr_egl_destroy_sync(renderer->egl, renderer->end_sync);
+	renderer->end_sync = EGL_NO_SYNC_KHR;
+
 	push_gles2_debug(renderer);
 
 	glViewport(0, 0, width, height);
@@ -58,8 +82,11 @@
 }
 
 static void gles2_end(struct wlr_renderer *wlr_renderer) {
-	gles2_get_renderer_in_context(wlr_renderer);
-	// no-op
+	struct wlr_gles2_renderer *renderer =
+		gles2_get_renderer_in_context(wlr_renderer);
+
+	assert(renderer->end_sync == EGL_NO_SYNC_KHR);
+	renderer->end_sync = wlr_egl_create_sync(renderer->egl, -1);
 }
 
 static void gles2_clear(struct wlr_renderer *wlr_renderer,
@@ -485,6 +512,8 @@
 	glDeleteProgram(renderer->shaders.tex_ext.program);
 	pop_gles2_debug(renderer);
 
+	wlr_egl_destroy_sync(renderer->egl, renderer->end_sync);
+
 	if (renderer->exts.debug_khr) {
 		glDisable(GL_DEBUG_OUTPUT_KHR);
 		renderer->procs.glDebugMessageCallbackKHR(NULL, NULL);
@@ -511,6 +540,8 @@
 	.get_dmabuf_formats = gles2_get_dmabuf_formats,
 	.preferred_read_format = gles2_preferred_read_format,
 	.read_pixels = gles2_read_pixels,
+	.dup_out_fence = gles2_dup_out_fence,
+	.wait_in_fence = gles2_wait_in_fence,
 	.texture_from_pixels = gles2_texture_from_pixels,
 	.texture_from_wl_drm = gles2_texture_from_wl_drm,
 	.texture_from_dmabuf = gles2_texture_from_dmabuf,
@@ -780,6 +811,7 @@
 	pop_gles2_debug(renderer);
 
 	wlr_egl_unset_current(renderer->egl);
+	renderer->end_sync = EGL_NO_SYNC_KHR;
 
 	return &renderer->wlr_renderer;
 
diff --git a/include/wlr/interfaces/wlr_output.h b/include/wlr/interfaces/wlr_output.h
index 13c9e6dc4..3eca21f40 100644
--- a/include/wlr/interfaces/wlr_output.h
+++ b/include/wlr/interfaces/wlr_output.h
@@ -38,7 +38,8 @@
 	 */
 	bool (*set_cursor)(struct wlr_output *output, struct wlr_texture *texture,
 		float scale, enum wl_output_transform transform,
-		int32_t hotspot_x, int32_t hotspot_y, bool update_texture);
+		int32_t hotspot_x, int32_t hotspot_y, bool update_texture,
+		struct wlr_buffer *buffer);
 	/**
 	 * Set the output cursor plane position.
 	 *
@@ -86,6 +87,7 @@
 	 */
 	bool (*export_dmabuf)(struct wlr_output *output,
 		struct wlr_dmabuf_attributes *attribs);
+	int (*get_out_fence)(struct wlr_output *output);
 };
 
 /**
